// Including all the libraries required for the Nurture Nest
#include <Adafruit_GFX.h>
#include <Adafruit_NeoMatrix.h>
#include <Adafruit_NeoPixel.h>
#include <CapacitiveSensor.h>
#include <DHT.h>

// -------------------- Sensors & Pins --------------------

// Capacitive touch sensor
CapacitiveSensor capSensor = CapacitiveSensor(8, 7);

// NeoPixel matrix
#define PIN 6
#define BRIGHTNESS 20
#define mw 8
#define mh 8
#define LED_BLACK 0

// Water level sensor
#define waterlevel A1

// Relay and moisture sensor
#define RELAY_PIN 5
#define MOISTURE_PIN A4
#define THRESHOLD 450

// Temperature & humidity sensor
#define DHTPIN 3
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// -------------------- Globals --------------------

int counter = 0;
int bilderanzahl = 0;

// NeoMatrix object
Adafruit_NeoMatrix *matrix = new Adafruit_NeoMatrix(
  mw, mh, PIN,
  NEO_MATRIX_TOP + NEO_MATRIX_LEFT +
  NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG,
  NEO_GRB + NEO_KHZ800
);

// -------------------- Bitmaps --------------------

static const uint16_t PROGMEM RGB_bmp[][64] = {

  // Smile - 0
  {
    0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,
    0x0F0,0xFFF,0xFFF,0x0F0,0x0F0,0xEEE,0xEEE,0x0F0,
    0x0F0,0xEEE,0xEEE,0x0F0,0x0F0,0xFFF,0xFFF,0x0F0,
    0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,
    0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,
    0x0F0,0xFFF,0x0F0,0x0F0,0x0F0,0x0F0,0xFFF,0x0F0,
    0x0F0,0x0F0,0xFFF,0xFFF,0xFFF,0xFFF,0x0F0,0x0F0,
    0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0,0x0F0
  },

  // Sad-blue - 1
  {
    0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,
    0xF60,0xF60,0xFFF,0xF60,0xF60,0xFFF,0xF60,0xF60,
    0xF60,0xFFF,0xFFF,0xF60,0xF60,0xFFF,0xFFF,0xF60,
    0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,
    0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,
    0xF60,0xF60,0xFFF,0xFFF,0xFFF,0xFFF,0xF60,0xF60,
    0xF60,0xFFF,0xF60,0xF60,0xF60,0xF60,0xFFF,0xF60,
    0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,0xF60,0xF60
  },

  // Sad-yellow - 2
  {
    0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,
    0x0FF,0x0FF,0xFFF,0x0FF,0x0FF,0xFFF,0x0FF,0x0FF,
    0x0FF,0xFFF,0xFFF,0x0FF,0x0FF,0xFFF,0xFFF,0x0FF,
    0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,
    0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,
    0x0FF,0xFFF,0xFFF,0xFFF,0xFFF,0xFFF,0xFFF,0x0FF,
    0x0FF,0xFFF,0x0FF,0x0FF,0x0FF,0x0FF,0xFFF,0x0FF,
    0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF,0x0FF
  },

  // Angry-red - 3
  {
    0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,
    0x00F,0xFFF,0x00F,0x00F,0x00F,0x00F,0xFFF,0x00F,
    0x00F,0xFFF,0xFFF,0x00F,0x00F,0xFFF,0xFFF,0x00F,
    0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,
    0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,
    0x00F,0xFFF,0xFFF,0xFFF,0xFFF,0xFFF,0xFFF,0x00F,
    0x00F,0xFFF,0x00F,0x00F,0x00F,0x00F,0xFFF,0x00F,
    0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,0x00F,0x00F
  },

  // LoveL - 4
  {
    0x60F,0x60F,0x60F,0x60F,0x60F,0x60F,0x60F,0x60F,
    0x60F,0xFFF,0x60F,0x60F,0x60F,0xFFF,0x60F,0x60F,
    0xFFF,0xFFF,0xFFF,0x60F,0xFFF,0xFFF,0xFFF,0x60F,
    0xFFF,0xFFF,0xFFF,0xFFF,0xFFF,0xFFF,0xFFF,0x60F,
    0x60F,0xFFF,0xFFF,0xFFF,0xFFF,0xFFF,0x60F,0x60F,
    0x60F,0xFFF,0xFFF,0xFFF,0xFFF,0xFFF,0x60F,0x60F,
    0x60F,0x60F,0xFFF,0xFFF,0xFFF,0x60F,0x60F,0x60F,
    0x60F,0x60F,0x60F,0xFFF,0x60F,0x60F,0x60F,0x60F
  }
};

// -------------------- Display Functions --------------------

void display_rgbBitmap(uint8_t bmp_num) {
  static uint16_t bmx = 0, bmy = 0;
  fixdrawRGBBitmap(bmx, bmy, RGB_bmp[bmp_num], 8, 8);
  bmx += 8;
  if (bmx >= mw) bmx = 0;
  if (!bmx) bmy += 8;
  if (bmy >= mh) bmy = 0;
  matrix->show();
}

// Convert 4/4/4 bitmap to RGB 5/6/5
void fixdrawRGBBitmap(int16_t x, int16_t y, const uint16_t *bitmap,
                      int16_t w, int16_t h) {

  uint16_t RGB_bmp_fixed[w * h];

  for (uint16_t pixel = 0; pixel < w * h; pixel++) {
    uint8_t r, g, b;
    uint16_t color = pgm_read_word(bitmap + pixel);

    b = (color & 0xF00) >> 8;
    g = (color & 0x0F0) >> 4;
    r = color & 0x00F;

    b = map(b, 0, 15, 0, 31);
    g = map(g, 0, 15, 0, 63);
    r = map(r, 0, 15, 0, 31);

    RGB_bmp_fixed[pixel] = (r << 11) + (g << 5) + b;
  }

  matrix->drawRGBBitmap(x, y, RGB_bmp_fixed, w, h);
}

// -------------------- Setup --------------------

void setup() {
  Serial.begin(115200);

  matrix->begin();
  matrix->setTextWrap(false);
  matrix->setBrightness(BRIGHTNESS);
  matrix->clear();

  pinMode(RELAY_PIN, OUTPUT);
  dht.begin();
}

// -------------------- Main Loop --------------------

void loop() {

  long touch = capSensor.capacitiveSensor(30);
  Serial.print("Touch: ");
  Serial.println(touch);

  int level = analogRead(waterlevel);
  int soilmoisture = analogRead(MOISTURE_PIN);

  float humidity = dht.readHumidity();
  float temperature = dht.readTemperature();

  // Watering logic
  if (soilmoisture < THRESHOLD) {
    digitalWrite(RELAY_PIN, HIGH); // pump off
    matrix->clear();
  } else {
    digitalWrite(RELAY_PIN, LOW);  // pump on
    matrix->clear();
  }

  // Petting interaction
  if (touch > 100) {
    display_rgbBitmap(4);
    delay(1000);
    display_rgbBitmap(5);
    delay(1000);
  }

  // Emotional states
  if (level < 170) {
    display_rgbBitmap(1); // sad-blue
    delay(1000);
  }

  if (temperature < 15 || temperature > 26) {
    display_rgbBitmap(2); // sad-yellow
    delay(1000);
  }

  if (level > 250) {
    display_rgbBitmap(0); // happy
    delay(1000);
  }

  if (level < 170 && temperature > 30) {
    display_rgbBitmap(3); // angry
    delay(1000);
  }

  delay(400); // prevent flooding
}
